/*
 * generated by Xtext 2.22.0
 */
package org.ccsl.serializer;

import ccsl.AtomicRule;
import ccsl.CompositeRule;
import ccsl.ccslPackage;
import ccsl.context.Context;
import ccsl.context.ContextPackage;
import ccsl.elements.ControlledAccessElement;
import ccsl.elements.Element;
import ccsl.elements.ElementsPackage;
import ccsl.elements.datatype.ArrayType;
import ccsl.elements.datatype.BooleanPrimitiveType;
import ccsl.elements.datatype.BytePrimitiveType;
import ccsl.elements.datatype.CharPrimitiveType;
import ccsl.elements.datatype.DataType;
import ccsl.elements.datatype.DatatypePackage;
import ccsl.elements.datatype.DoublePrimitiveType;
import ccsl.elements.datatype.FloatPrimitiveType;
import ccsl.elements.datatype.IntPrimitiveType;
import ccsl.elements.datatype.LongPrimitiveType;
import ccsl.elements.datatype.ObjectType;
import ccsl.elements.datatype.ParameterizedType;
import ccsl.elements.datatype.PrimitiveType;
import ccsl.elements.datatype.ShortPrimitiveType;
import ccsl.elements.datatype.TypeParameter;
import ccsl.elements.datatype.VoidType;
import ccsl.elements.datatype.WildCardType;
import ccsl.elements.expressions.ArithmeticExpression;
import ccsl.elements.expressions.BinaryExpression;
import ccsl.elements.expressions.BooleanExpression;
import ccsl.elements.expressions.CastExpression;
import ccsl.elements.expressions.Expression;
import ccsl.elements.expressions.ExpressionsPackage;
import ccsl.elements.expressions.InstanceofExpression;
import ccsl.elements.expressions.OperandExpression;
import ccsl.elements.expressions.StringConcatenation;
import ccsl.elements.expressions.TernaryExpression;
import ccsl.elements.expressions.VarDeclaration;
import ccsl.elements.expressions.annotation.Annotation;
import ccsl.elements.expressions.annotation.AnnotationFieldValue;
import ccsl.elements.expressions.annotation.AnnotationPackage;
import ccsl.elements.namedElements.NamedElement;
import ccsl.elements.namedElements.NamedElementsPackage;
import ccsl.elements.namedElements.complexType.AnnotationField;
import ccsl.elements.namedElements.complexType.AnnotationType;
import ccsl.elements.namedElements.complexType.AnonymousClass;
import ccsl.elements.namedElements.complexType.ComplexType;
import ccsl.elements.namedElements.complexType.ComplexTypeDeclaration;
import ccsl.elements.namedElements.complexType.ComplexTypePackage;
import ccsl.elements.namedElements.complexType.ConstructComplexTypeDeclaration;
import ccsl.elements.namedElements.complexType.EnumConstant;
import ccsl.elements.namedElements.complexType.JClass;
import ccsl.elements.namedElements.complexType.JEnum;
import ccsl.elements.namedElements.complexType.JInterface;
import ccsl.elements.namedElements.complexType.TypeDeclaration;
import ccsl.elements.namedElements.method.Constructor;
import ccsl.elements.namedElements.method.Method;
import ccsl.elements.namedElements.method.MethodPackage;
import ccsl.elements.namedElements.method.SimpleMethod;
import ccsl.elements.namedElements.variable.FieldVariable;
import ccsl.elements.namedElements.variable.InitializableVariable;
import ccsl.elements.namedElements.variable.LocalVariable;
import ccsl.elements.namedElements.variable.ParameterVariable;
import ccsl.elements.namedElements.variable.Variable;
import ccsl.elements.namedElements.variable.VariablePackage;
import ccsl.elements.statements.AssertStatement;
import ccsl.elements.statements.Block;
import ccsl.elements.statements.BreakStatement;
import ccsl.elements.statements.ContinueStatement;
import ccsl.elements.statements.ControlFlowStatement;
import ccsl.elements.statements.EmptyStatement;
import ccsl.elements.statements.ExpressionStatement;
import ccsl.elements.statements.InstanceCreation;
import ccsl.elements.statements.LabelStatement;
import ccsl.elements.statements.ReturnStatement;
import ccsl.elements.statements.Statement;
import ccsl.elements.statements.StatementsPackage;
import ccsl.elements.statements.SynchronizedBlock;
import ccsl.elements.statements.ThrowStatement;
import ccsl.elements.statements.import_.ImportPackage;
import ccsl.elements.statements.import_.ImportStatement;
import ccsl.elements.statements.import_.ImportableElement;
import ccsl.functions.booleanFunctions.filters.AtomicFilter;
import ccsl.functions.booleanFunctions.filters.BlockLastStatementFilter;
import ccsl.functions.booleanFunctions.filters.ChildClosureComplexTypeFilter;
import ccsl.functions.booleanFunctions.filters.CompositeFilter;
import ccsl.functions.booleanFunctions.filters.CountFilter;
import ccsl.functions.booleanFunctions.filters.FiltersPackage;
import ccsl.functions.booleanFunctions.filters.FromClosureFilter;
import ccsl.functions.booleanFunctions.filters.HasSameReferenceFilter;
import ccsl.functions.booleanFunctions.filters.HasSuperClassFilter;
import ccsl.functions.booleanFunctions.filters.ImplicitContentsFilter;
import ccsl.functions.booleanFunctions.filters.ImplicityContainerFilter;
import ccsl.functions.booleanFunctions.filters.ImplicityOperandFilter;
import ccsl.functions.booleanFunctions.filters.IsEmptyBlockFilter;
import ccsl.functions.booleanFunctions.filters.IsKindOfFilter;
import ccsl.functions.booleanFunctions.filters.IsStringFilter;
import ccsl.functions.booleanFunctions.filters.IsTypeOfFilter;
import ccsl.functions.booleanFunctions.filters.PropertyFilter;
import ccsl.functions.booleanFunctions.filters.RegexMatch;
import ccsl.functions.booleanFunctions.filters.SameNameFilter;
import ccsl.functions.booleanFunctions.filters.SuperMethodClosureFilter;
import ccsl.functions.booleanFunctions.filters.TemplateFilter;
import com.google.inject.Inject;
import java.util.Set;
import org.ccsl.services.TextualGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class TextualSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private TextualGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == AnnotationPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case AnnotationPackage.ANNOTATION:
				sequence_Annotation(context, (Annotation) semanticObject); 
				return; 
			case AnnotationPackage.ANNOTATION_FIELD_VALUE:
				sequence_AnnotationFieldValue(context, (AnnotationFieldValue) semanticObject); 
				return; 
			}
		else if (epackage == ccslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ccslPackage.ATOMIC_RULE:
				sequence_AtomicRule(context, (AtomicRule) semanticObject); 
				return; 
			case ccslPackage.COMPOSITE_RULE:
				sequence_CompositeRule(context, (CompositeRule) semanticObject); 
				return; 
			}
		else if (epackage == ComplexTypePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ComplexTypePackage.ANNOTATION_FIELD:
				sequence_AnnotationField(context, (AnnotationField) semanticObject); 
				return; 
			case ComplexTypePackage.ANNOTATION_TYPE:
				sequence_AnnotationType(context, (AnnotationType) semanticObject); 
				return; 
			case ComplexTypePackage.ANONYMOUS_CLASS:
				sequence_AnonymousClass(context, (AnonymousClass) semanticObject); 
				return; 
			case ComplexTypePackage.COMPLEX_TYPE:
				sequence_ComplexType_Impl(context, (ComplexType) semanticObject); 
				return; 
			case ComplexTypePackage.COMPLEX_TYPE_DECLARATION:
				sequence_ComplexTypeDeclaration_Impl(context, (ComplexTypeDeclaration) semanticObject); 
				return; 
			case ComplexTypePackage.CONSTRUCT_COMPLEX_TYPE_DECLARATION:
				sequence_ConstructComplexTypeDeclaration_Impl(context, (ConstructComplexTypeDeclaration) semanticObject); 
				return; 
			case ComplexTypePackage.ENUM_CONSTANT:
				sequence_EnumConstant(context, (EnumConstant) semanticObject); 
				return; 
			case ComplexTypePackage.JCLASS:
				sequence_JClass(context, (JClass) semanticObject); 
				return; 
			case ComplexTypePackage.JENUM:
				sequence_JEnum(context, (JEnum) semanticObject); 
				return; 
			case ComplexTypePackage.JINTERFACE:
				sequence_JInterface(context, (JInterface) semanticObject); 
				return; 
			case ComplexTypePackage.TYPE_DECLARATION:
				sequence_TypeDeclaration_Impl(context, (TypeDeclaration) semanticObject); 
				return; 
			}
		else if (epackage == ContextPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ContextPackage.CONTEXT:
				sequence_Context(context, (Context) semanticObject); 
				return; 
			}
		else if (epackage == DatatypePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case DatatypePackage.ARRAY_TYPE:
				sequence_ArrayType(context, (ArrayType) semanticObject); 
				return; 
			case DatatypePackage.BOOLEAN_PRIMITIVE_TYPE:
				sequence_BooleanPrimitiveType(context, (BooleanPrimitiveType) semanticObject); 
				return; 
			case DatatypePackage.BYTE_PRIMITIVE_TYPE:
				sequence_BytePrimitiveType(context, (BytePrimitiveType) semanticObject); 
				return; 
			case DatatypePackage.CHAR_PRIMITIVE_TYPE:
				sequence_CharPrimitiveType(context, (CharPrimitiveType) semanticObject); 
				return; 
			case DatatypePackage.DATA_TYPE:
				sequence_DataType_Impl(context, (DataType) semanticObject); 
				return; 
			case DatatypePackage.DOUBLE_PRIMITIVE_TYPE:
				sequence_DoublePrimitiveType(context, (DoublePrimitiveType) semanticObject); 
				return; 
			case DatatypePackage.FLOAT_PRIMITIVE_TYPE:
				sequence_FloatPrimitiveType(context, (FloatPrimitiveType) semanticObject); 
				return; 
			case DatatypePackage.INT_PRIMITIVE_TYPE:
				sequence_IntPrimitiveType(context, (IntPrimitiveType) semanticObject); 
				return; 
			case DatatypePackage.LONG_PRIMITIVE_TYPE:
				sequence_LongPrimitiveType(context, (LongPrimitiveType) semanticObject); 
				return; 
			case DatatypePackage.OBJECT_TYPE:
				sequence_ObjectType_Impl(context, (ObjectType) semanticObject); 
				return; 
			case DatatypePackage.PARAMETERIZED_TYPE:
				sequence_ParameterizedType(context, (ParameterizedType) semanticObject); 
				return; 
			case DatatypePackage.PRIMITIVE_TYPE:
				sequence_PrimitiveType_Impl(context, (PrimitiveType) semanticObject); 
				return; 
			case DatatypePackage.SHORT_PRIMITIVE_TYPE:
				sequence_ShortPrimitiveType(context, (ShortPrimitiveType) semanticObject); 
				return; 
			case DatatypePackage.TYPE_PARAMETER:
				sequence_TypeParameter(context, (TypeParameter) semanticObject); 
				return; 
			case DatatypePackage.VOID_TYPE:
				sequence_VoidType(context, (VoidType) semanticObject); 
				return; 
			case DatatypePackage.WILD_CARD_TYPE:
				sequence_WildCardType(context, (WildCardType) semanticObject); 
				return; 
			}
		else if (epackage == ElementsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ElementsPackage.CONTROLLED_ACCESS_ELEMENT:
				sequence_ControlledAccessElement(context, (ControlledAccessElement) semanticObject); 
				return; 
			case ElementsPackage.ELEMENT:
				sequence_Element(context, (Element) semanticObject); 
				return; 
			}
		else if (epackage == ExpressionsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ExpressionsPackage.ARITHMETIC_EXPRESSION:
				sequence_ArithmeticExpression(context, (ArithmeticExpression) semanticObject); 
				return; 
			case ExpressionsPackage.BINARY_EXPRESSION:
				sequence_BinaryExpression(context, (BinaryExpression) semanticObject); 
				return; 
			case ExpressionsPackage.BOOLEAN_EXPRESSION:
				sequence_BooleanExpression(context, (BooleanExpression) semanticObject); 
				return; 
			case ExpressionsPackage.CAST_EXPRESSION:
				sequence_CastExpression(context, (CastExpression) semanticObject); 
				return; 
			case ExpressionsPackage.EXPRESSION:
				sequence_Expression_Impl(context, (Expression) semanticObject); 
				return; 
			case ExpressionsPackage.INSTANCEOF_EXPRESSION:
				sequence_InstanceofExpression(context, (InstanceofExpression) semanticObject); 
				return; 
			case ExpressionsPackage.OPERAND_EXPRESSION:
				sequence_OperandExpression_Impl(context, (OperandExpression) semanticObject); 
				return; 
			case ExpressionsPackage.STRING_CONCATENATION:
				sequence_StringConcatenation(context, (StringConcatenation) semanticObject); 
				return; 
			case ExpressionsPackage.TERNARY_EXPRESSION:
				sequence_TernaryExpression(context, (TernaryExpression) semanticObject); 
				return; 
			case ExpressionsPackage.VAR_DECLARATION:
				sequence_VarDeclaration(context, (VarDeclaration) semanticObject); 
				return; 
			}
		else if (epackage == FiltersPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case FiltersPackage.ATOMIC_FILTER:
				sequence_AtomicFilter_Impl(context, (AtomicFilter) semanticObject); 
				return; 
			case FiltersPackage.BLOCK_LAST_STATEMENT_FILTER:
				sequence_BlockLastStatementFilter(context, (BlockLastStatementFilter) semanticObject); 
				return; 
			case FiltersPackage.CHILD_CLOSURE_COMPLEX_TYPE_FILTER:
				sequence_ChildClosureComplexTypeFilter(context, (ChildClosureComplexTypeFilter) semanticObject); 
				return; 
			case FiltersPackage.COMPOSITE_FILTER:
				sequence_CompositeFilter(context, (CompositeFilter) semanticObject); 
				return; 
			case FiltersPackage.COUNT_FILTER:
				sequence_CountFilter(context, (CountFilter) semanticObject); 
				return; 
			case FiltersPackage.FROM_CLOSURE_FILTER:
				sequence_FromClosureFilter(context, (FromClosureFilter) semanticObject); 
				return; 
			case FiltersPackage.HAS_SAME_REFERENCE_FILTER:
				sequence_HasSameReferenceFilter(context, (HasSameReferenceFilter) semanticObject); 
				return; 
			case FiltersPackage.HAS_SUPER_CLASS_FILTER:
				sequence_HasSuperClassFilter(context, (HasSuperClassFilter) semanticObject); 
				return; 
			case FiltersPackage.IMPLICIT_CONTENTS_FILTER:
				sequence_ImplicitContentsFilter(context, (ImplicitContentsFilter) semanticObject); 
				return; 
			case FiltersPackage.IMPLICITY_CONTAINER_FILTER:
				sequence_ImplicityContainerFilter(context, (ImplicityContainerFilter) semanticObject); 
				return; 
			case FiltersPackage.IMPLICITY_OPERAND_FILTER:
				sequence_ImplicityOperandFilter(context, (ImplicityOperandFilter) semanticObject); 
				return; 
			case FiltersPackage.IS_EMPTY_BLOCK_FILTER:
				sequence_IsEmptyBlockFilter(context, (IsEmptyBlockFilter) semanticObject); 
				return; 
			case FiltersPackage.IS_KIND_OF_FILTER:
				sequence_IsKindOfFilter(context, (IsKindOfFilter) semanticObject); 
				return; 
			case FiltersPackage.IS_STRING_FILTER:
				sequence_IsStringFilter(context, (IsStringFilter) semanticObject); 
				return; 
			case FiltersPackage.IS_TYPE_OF_FILTER:
				sequence_IsTypeOfFilter(context, (IsTypeOfFilter) semanticObject); 
				return; 
			case FiltersPackage.PROPERTY_FILTER:
				sequence_PropertyFilter(context, (PropertyFilter) semanticObject); 
				return; 
			case FiltersPackage.REGEX_MATCH:
				sequence_RegexMatch(context, (RegexMatch) semanticObject); 
				return; 
			case FiltersPackage.SAME_NAME_FILTER:
				sequence_SameNameFilter(context, (SameNameFilter) semanticObject); 
				return; 
			case FiltersPackage.SUPER_METHOD_CLOSURE_FILTER:
				sequence_SuperMethodClosureFilter(context, (SuperMethodClosureFilter) semanticObject); 
				return; 
			case FiltersPackage.TEMPLATE_FILTER:
				sequence_TemplateFilter_Impl(context, (TemplateFilter) semanticObject); 
				return; 
			}
		else if (epackage == ImportPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ImportPackage.IMPORT_STATEMENT:
				sequence_ImportStatement(context, (ImportStatement) semanticObject); 
				return; 
			case ImportPackage.IMPORTABLE_ELEMENT:
				sequence_ImportableElement(context, (ImportableElement) semanticObject); 
				return; 
			}
		else if (epackage == MethodPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MethodPackage.CONSTRUCTOR:
				sequence_Constructor(context, (Constructor) semanticObject); 
				return; 
			case MethodPackage.METHOD:
				sequence_Method(context, (Method) semanticObject); 
				return; 
			case MethodPackage.SIMPLE_METHOD:
				sequence_SimpleMethod(context, (SimpleMethod) semanticObject); 
				return; 
			}
		else if (epackage == NamedElementsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case NamedElementsPackage.NAMED_ELEMENT:
				sequence_NamedElement_Impl(context, (NamedElement) semanticObject); 
				return; 
			case NamedElementsPackage.PACKAGE:
				sequence_Package(context, (ccsl.elements.namedElements.Package) semanticObject); 
				return; 
			}
		else if (epackage == StatementsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case StatementsPackage.ASSERT_STATEMENT:
				sequence_AssertStatement(context, (AssertStatement) semanticObject); 
				return; 
			case StatementsPackage.BLOCK:
				sequence_Block(context, (Block) semanticObject); 
				return; 
			case StatementsPackage.BREAK_STATEMENT:
				sequence_BreakStatement(context, (BreakStatement) semanticObject); 
				return; 
			case StatementsPackage.CONTINUE_STATEMENT:
				sequence_ContinueStatement(context, (ContinueStatement) semanticObject); 
				return; 
			case StatementsPackage.CONTROL_FLOW_STATEMENT:
				sequence_ControlFlowStatement(context, (ControlFlowStatement) semanticObject); 
				return; 
			case StatementsPackage.EMPTY_STATEMENT:
				sequence_EmptyStatement(context, (EmptyStatement) semanticObject); 
				return; 
			case StatementsPackage.EXPRESSION_STATEMENT:
				sequence_ExpressionStatement(context, (ExpressionStatement) semanticObject); 
				return; 
			case StatementsPackage.INSTANCE_CREATION:
				sequence_InstanceCreation(context, (InstanceCreation) semanticObject); 
				return; 
			case StatementsPackage.LABEL_STATEMENT:
				sequence_LabelStatement(context, (LabelStatement) semanticObject); 
				return; 
			case StatementsPackage.RETURN_STATEMENT:
				sequence_ReturnStatement(context, (ReturnStatement) semanticObject); 
				return; 
			case StatementsPackage.STATEMENT:
				sequence_Statement_Impl(context, (Statement) semanticObject); 
				return; 
			case StatementsPackage.SYNCHRONIZED_BLOCK:
				sequence_SynchronizedBlock(context, (SynchronizedBlock) semanticObject); 
				return; 
			case StatementsPackage.THROW_STATEMENT:
				sequence_ThrowStatement(context, (ThrowStatement) semanticObject); 
				return; 
			}
		else if (epackage == VariablePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case VariablePackage.FIELD_VARIABLE:
				sequence_FieldVariable(context, (FieldVariable) semanticObject); 
				return; 
			case VariablePackage.INITIALIZABLE_VARIABLE:
				sequence_InitializableVariable_Impl(context, (InitializableVariable) semanticObject); 
				return; 
			case VariablePackage.LOCAL_VARIABLE:
				sequence_LocalVariable(context, (LocalVariable) semanticObject); 
				return; 
			case VariablePackage.PARAMETER_VARIABLE:
				sequence_ParameterVariable(context, (ParameterVariable) semanticObject); 
				return; 
			case VariablePackage.VARIABLE:
				sequence_Variable_Impl(context, (Variable) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Element returns AnnotationFieldValue
	 *     AnnotationFieldValue returns AnnotationFieldValue
	 *
	 * Constraint:
	 *     (uniqueName=String0? field=[AnnotationField|EString]? value=Expression?)
	 */
	protected void sequence_AnnotationFieldValue(ISerializationContext context, AnnotationFieldValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AnnotationField returns AnnotationField
	 *
	 * Constraint:
	 *     (
	 *         uniqueName=String0? 
	 *         name=String0? 
	 *         availableInSourceCode=BooleanObject? 
	 *         type=[DataType|EString]? 
	 *         (annotations+=Annotation annotations+=Annotation*)? 
	 *         default=Expression?
	 *     )
	 */
	protected void sequence_AnnotationField(ISerializationContext context, AnnotationField semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeDeclaration returns AnnotationType
	 *     AnnotationType returns AnnotationType
	 *
	 * Constraint:
	 *     (
	 *         uniqueName=String0? 
	 *         name=String0? 
	 *         availableInSourceCode=BooleanObject? 
	 *         visibility=Visibility? 
	 *         static=BooleanObject? 
	 *         inheritance=Inheritance? 
	 *         (annotations+=Annotation annotations+=Annotation*)? 
	 *         (imports+=ImportStatement imports+=ImportStatement*)? 
	 *         (nestedTypes+=TypeDeclaration nestedTypes+=TypeDeclaration*)? 
	 *         (fields+=AnnotationField fields+=AnnotationField*)?
	 *     )
	 */
	protected void sequence_AnnotationType(ISerializationContext context, AnnotationType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Annotation returns Annotation
	 *
	 * Constraint:
	 *     (uniqueName=EString? valuesKind=CollectionKind? type=[AnnotationType|EString]? (values+=AnnotationFieldValue values+=AnnotationFieldValue*)?)
	 */
	protected void sequence_Annotation(ISerializationContext context, Annotation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ComplexType returns AnonymousClass
	 *     Element returns AnonymousClass
	 *     AnonymousClass returns AnonymousClass
	 *
	 * Constraint:
	 *     (
	 *         uniqueName=String0? 
	 *         fieldsKind=CollectionKind? 
	 *         methodsKind=CollectionKind? 
	 *         type=[ObjectType|EString]? 
	 *         (fields+=FieldVariable fields+=FieldVariable*)? 
	 *         (methods+=Method methods+=Method*)?
	 *     )
	 */
	protected void sequence_AnonymousClass(ISerializationContext context, AnonymousClass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ArithmeticExpression
	 *     Element returns ArithmeticExpression
	 *     ArithmeticExpression returns ArithmeticExpression
	 *
	 * Constraint:
	 *     (uniqueName=String0? kind=ExpressionKind? operandsKind=CollectionKind? operator=ArithmeticOperator? (operands+=Expression operands+=Expression*)?)
	 */
	protected void sequence_ArithmeticExpression(ISerializationContext context, ArithmeticExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataType returns ArrayType
	 *     ObjectType returns ArrayType
	 *     Element returns ArrayType
	 *     ArrayType returns ArrayType
	 *
	 * Constraint:
	 *     (uniqueName=String0? dimensions=Int0? type=[DataType|EString]?)
	 */
	protected void sequence_ArrayType(ISerializationContext context, ArrayType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns AssertStatement
	 *     Element returns AssertStatement
	 *     AssertStatement returns AssertStatement
	 *
	 * Constraint:
	 *     (uniqueName=String0? expression=Expression? message=Expression?)
	 */
	protected void sequence_AssertStatement(ISerializationContext context, AssertStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Filter returns AtomicFilter
	 *     AtomicFilter_Impl returns AtomicFilter
	 *
	 * Constraint:
	 *     (negated?='not'? targets+=[Element|EString] targets+=[Element|EString]*)
	 */
	protected void sequence_AtomicFilter_Impl(ISerializationContext context, AtomicFilter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Rule returns AtomicRule
	 *     AtomicRule returns AtomicRule
	 *
	 * Constraint:
	 *     (negated?='not'? context=Context subject=[Element|EString])
	 */
	protected void sequence_AtomicRule(ISerializationContext context, AtomicRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BinaryExpression
	 *     Element returns BinaryExpression
	 *     BinaryExpression returns BinaryExpression
	 *
	 * Constraint:
	 *     (uniqueName=String0? kind=ExpressionKind? operandsKind=CollectionKind? operator=BinaryOperator? (operands+=Expression operands+=Expression*)?)
	 */
	protected void sequence_BinaryExpression(ISerializationContext context, BinaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Filter returns BlockLastStatementFilter
	 *     BlockLastStatementFilter returns BlockLastStatementFilter
	 *
	 * Constraint:
	 *     (negated?='not'? targets+=[Element|EString] targets+=[Element|EString]* lastStatement=[Statement|EString]? context=Context?)
	 */
	protected void sequence_BlockLastStatementFilter(ISerializationContext context, BlockLastStatementFilter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Block
	 *     Element returns Block
	 *     Block returns Block
	 *
	 * Constraint:
	 *     (uniqueName=String0? statementsKind=CollectionKind? (statements+=Statement statements+=Statement*)?)
	 */
	protected void sequence_Block(ISerializationContext context, Block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BooleanExpression
	 *     Element returns BooleanExpression
	 *     BooleanExpression returns BooleanExpression
	 *
	 * Constraint:
	 *     (uniqueName=String0? kind=ExpressionKind? operandsKind=CollectionKind? operator=BooleanOperator? (operands+=Expression operands+=Expression*)?)
	 */
	protected void sequence_BooleanExpression(ISerializationContext context, BooleanExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataType returns BooleanPrimitiveType
	 *     Element returns BooleanPrimitiveType
	 *     BooleanPrimitiveType returns BooleanPrimitiveType
	 *
	 * Constraint:
	 *     uniqueName=String0?
	 */
	protected void sequence_BooleanPrimitiveType(ISerializationContext context, BooleanPrimitiveType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns BreakStatement
	 *     Element returns BreakStatement
	 *     BreakStatement returns BreakStatement
	 *
	 * Constraint:
	 *     uniqueName=String0?
	 */
	protected void sequence_BreakStatement(ISerializationContext context, BreakStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataType returns BytePrimitiveType
	 *     Element returns BytePrimitiveType
	 *     BytePrimitiveType returns BytePrimitiveType
	 *
	 * Constraint:
	 *     uniqueName=String0?
	 */
	protected void sequence_BytePrimitiveType(ISerializationContext context, BytePrimitiveType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns CastExpression
	 *     Element returns CastExpression
	 *     CastExpression returns CastExpression
	 *
	 * Constraint:
	 *     (uniqueName=String0? type=[DataType|EString]? expression=Expression?)
	 */
	protected void sequence_CastExpression(ISerializationContext context, CastExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataType returns CharPrimitiveType
	 *     Element returns CharPrimitiveType
	 *     CharPrimitiveType returns CharPrimitiveType
	 *
	 * Constraint:
	 *     uniqueName=String0?
	 */
	protected void sequence_CharPrimitiveType(ISerializationContext context, CharPrimitiveType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Filter returns ChildClosureComplexTypeFilter
	 *     ChildClosureComplexTypeFilter returns ChildClosureComplexTypeFilter
	 *
	 * Constraint:
	 *     (
	 *         negated?='not'? 
	 *         targets+=[Element|EString] 
	 *         targets+=[Element|EString]* 
	 *         superComplexType=[ComplexType|EString] 
	 *         childComplexType=[ComplexType|EString] 
	 *         context=Context
	 *     )
	 */
	protected void sequence_ChildClosureComplexTypeFilter(ISerializationContext context, ChildClosureComplexTypeFilter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeDeclaration returns ComplexTypeDeclaration
	 *     ComplexType returns ComplexTypeDeclaration
	 *     Element returns ComplexTypeDeclaration
	 *     ComplexTypeDeclaration_Impl returns ComplexTypeDeclaration
	 *
	 * Constraint:
	 *     (
	 *         uniqueName=String0? 
	 *         name=String0? 
	 *         availableInSourceCode=BooleanObject? 
	 *         visibility=Visibility? 
	 *         static=BooleanObject? 
	 *         inheritance=Inheritance? 
	 *         fieldsKind=CollectionKind? 
	 *         methodsKind=CollectionKind? 
	 *         (superInterfaces+=[JInterface|EString] superInterfaces+=[JInterface|EString]*)? 
	 *         (annotations+=Annotation annotations+=Annotation*)? 
	 *         (imports+=ImportStatement imports+=ImportStatement*)? 
	 *         (nestedTypes+=TypeDeclaration nestedTypes+=TypeDeclaration*)? 
	 *         (fields+=FieldVariable fields+=FieldVariable*)? 
	 *         (methods+=Method methods+=Method*)?
	 *     )
	 */
	protected void sequence_ComplexTypeDeclaration_Impl(ISerializationContext context, ComplexTypeDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ComplexType returns ComplexType
	 *     Element returns ComplexType
	 *     ComplexType_Impl returns ComplexType
	 *
	 * Constraint:
	 *     (
	 *         uniqueName=String0? 
	 *         fieldsKind=CollectionKind? 
	 *         methodsKind=CollectionKind? 
	 *         (fields+=FieldVariable fields+=FieldVariable*)? 
	 *         (methods+=Method methods+=Method*)?
	 *     )
	 */
	protected void sequence_ComplexType_Impl(ISerializationContext context, ComplexType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Filter returns CompositeFilter
	 *     CompositeFilter returns CompositeFilter
	 *
	 * Constraint:
	 *     (negated?='not'? operator=LogicOperator? filters+=Filter filters+=Filter*)
	 */
	protected void sequence_CompositeFilter(ISerializationContext context, CompositeFilter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Rule returns CompositeRule
	 *     CompositeRule returns CompositeRule
	 *
	 * Constraint:
	 *     (negated?='not'? operator=LogicOperator? rules+=Rule rules+=Rule*)
	 */
	protected void sequence_CompositeRule(ISerializationContext context, CompositeRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeDeclaration returns ConstructComplexTypeDeclaration
	 *     ComplexType returns ConstructComplexTypeDeclaration
	 *     Element returns ConstructComplexTypeDeclaration
	 *     ConstructComplexTypeDeclaration_Impl returns ConstructComplexTypeDeclaration
	 *
	 * Constraint:
	 *     (
	 *         uniqueName=String0? 
	 *         name=String0? 
	 *         availableInSourceCode=BooleanObject? 
	 *         visibility=Visibility? 
	 *         static=BooleanObject? 
	 *         inheritance=Inheritance? 
	 *         fieldsKind=CollectionKind? 
	 *         methodsKind=CollectionKind? 
	 *         (superInterfaces+=[JInterface|EString] superInterfaces+=[JInterface|EString]*)? 
	 *         (annotations+=Annotation annotations+=Annotation*)? 
	 *         (imports+=ImportStatement imports+=ImportStatement*)? 
	 *         (nestedTypes+=TypeDeclaration nestedTypes+=TypeDeclaration*)? 
	 *         (fields+=FieldVariable fields+=FieldVariable*)? 
	 *         (methods+=Method methods+=Method*)? 
	 *         (constructors+=Constructor constructors+=Constructor*)?
	 *     )
	 */
	protected void sequence_ConstructComplexTypeDeclaration_Impl(ISerializationContext context, ConstructComplexTypeDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Constructor returns Constructor
	 *
	 * Constraint:
	 *     (
	 *         uniqueName=String0? 
	 *         visibility=Visibility? 
	 *         paramsKind=CollectionKind? 
	 *         avaliableInSourceCode=BooleanObject? 
	 *         (thrownExceptions+=[JClass|EString] thrownExceptions+=[JClass|EString]*)? 
	 *         (annotations+=Annotation annotations+=Annotation*)? 
	 *         (params+=ParameterVariable params+=ParameterVariable*)? 
	 *         body=Block?
	 *     )
	 */
	protected void sequence_Constructor(ISerializationContext context, Constructor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Context returns Context
	 *
	 * Constraint:
	 *     ((contextElements+=Element contextElements+=Element*)? (filters+=Filter filters+=Filter*)?)
	 */
	protected void sequence_Context(ISerializationContext context, Context semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ContinueStatement
	 *     Element returns ContinueStatement
	 *     ContinueStatement returns ContinueStatement
	 *
	 * Constraint:
	 *     uniqueName=String0?
	 */
	protected void sequence_ContinueStatement(ISerializationContext context, ContinueStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ControlFlowStatement
	 *     Element returns ControlFlowStatement
	 *     ControlFlowStatement returns ControlFlowStatement
	 *
	 * Constraint:
	 *     uniqueName=String0?
	 */
	protected void sequence_ControlFlowStatement(ISerializationContext context, ControlFlowStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Element returns ControlledAccessElement
	 *     ControlledAccessElement returns ControlledAccessElement
	 *
	 * Constraint:
	 *     (uniqueName=String0? visibility=Visibility?)
	 */
	protected void sequence_ControlledAccessElement(ISerializationContext context, ControlledAccessElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Filter returns CountFilter
	 *     CountFilter returns CountFilter
	 *
	 * Constraint:
	 *     (
	 *         negated?='not'? 
	 *         min=Int0? 
	 *         max=Int0? 
	 *         targets+=[Element|EString] 
	 *         targets+=[Element|EString]* 
	 *         container=[Element|EString]? 
	 *         field=[Element|EString] 
	 *         context+=Context 
	 *         context+=Context*
	 *     )
	 */
	protected void sequence_CountFilter(ISerializationContext context, CountFilter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataType returns DataType
	 *     Element returns DataType
	 *     DataType_Impl returns DataType
	 *
	 * Constraint:
	 *     uniqueName=EString?
	 */
	protected void sequence_DataType_Impl(ISerializationContext context, DataType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataType returns DoublePrimitiveType
	 *     Element returns DoublePrimitiveType
	 *     DoublePrimitiveType returns DoublePrimitiveType
	 *
	 * Constraint:
	 *     uniqueName=String0?
	 */
	protected void sequence_DoublePrimitiveType(ISerializationContext context, DoublePrimitiveType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Element returns Element
	 *
	 * Constraint:
	 *     uniqueName=EString
	 */
	protected void sequence_Element(ISerializationContext context, Element semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ElementsPackage.Literals.ELEMENT__UNIQUE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ElementsPackage.Literals.ELEMENT__UNIQUE_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getElementAccess().getUniqueNameEStringParserRuleCall_0_1_0(), semanticObject.getUniqueName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns EmptyStatement
	 *     Element returns EmptyStatement
	 *     EmptyStatement returns EmptyStatement
	 *
	 * Constraint:
	 *     uniqueName=String0?
	 */
	protected void sequence_EmptyStatement(ISerializationContext context, EmptyStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EnumConstant returns EnumConstant
	 *
	 * Constraint:
	 *     (
	 *         uniqueName=String0? 
	 *         name=String0? 
	 *         availableInSourceCode=BooleanObject? 
	 *         argumentsKind=CollectionKind? 
	 *         (annotations+=Annotation annotations+=Annotation*)? 
	 *         (arguments+=Expression arguments+=Expression*)?
	 *     )
	 */
	protected void sequence_EnumConstant(ISerializationContext context, EnumConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ExpressionStatement
	 *     Element returns ExpressionStatement
	 *     ExpressionStatement returns ExpressionStatement
	 *
	 * Constraint:
	 *     (uniqueName=String0? expression=Expression?)
	 */
	protected void sequence_ExpressionStatement(ISerializationContext context, ExpressionStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Expression
	 *     Element returns Expression
	 *     Expression_Impl returns Expression
	 *
	 * Constraint:
	 *     uniqueName=String0?
	 */
	protected void sequence_Expression_Impl(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns FieldVariable
	 *     FieldVariable returns FieldVariable
	 *
	 * Constraint:
	 *     (
	 *         uniqueName=String0? 
	 *         name=String0? 
	 *         availableInSourceCode=BooleanObject? 
	 *         final=BooleanObject? 
	 *         visibility=Visibility? 
	 *         static=BooleanObject? 
	 *         volatile=BooleanObject? 
	 *         type=[DataType|EString]? 
	 *         (annotations+=Annotation annotations+=Annotation*)? 
	 *         initialValue=Expression?
	 *     )
	 */
	protected void sequence_FieldVariable(ISerializationContext context, FieldVariable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataType returns FloatPrimitiveType
	 *     Element returns FloatPrimitiveType
	 *     FloatPrimitiveType returns FloatPrimitiveType
	 *
	 * Constraint:
	 *     uniqueName=String0?
	 */
	protected void sequence_FloatPrimitiveType(ISerializationContext context, FloatPrimitiveType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Filter returns FromClosureFilter
	 *     FromClosureFilter returns FromClosureFilter
	 *
	 * Constraint:
	 *     (negated?='not'? targets+=[Element|EString] targets+=[Element|EString]* from=[Statement|EString] context=Context?)
	 */
	protected void sequence_FromClosureFilter(ISerializationContext context, FromClosureFilter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Filter returns HasSameReferenceFilter
	 *     HasSameReferenceFilter returns HasSameReferenceFilter
	 *
	 * Constraint:
	 *     (negated?='not'? targets+=[Element|EString] targets+=[Element|EString]*)
	 */
	protected void sequence_HasSameReferenceFilter(ISerializationContext context, HasSameReferenceFilter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Filter returns HasSuperClassFilter
	 *     HasSuperClassFilter returns HasSuperClassFilter
	 *
	 * Constraint:
	 *     (
	 *         negated?='not'? 
	 *         includesTarget=Boolean? 
	 *         targets+=[Element|EString] 
	 *         targets+=[Element|EString]* 
	 *         superClass=[JClass|EString]? 
	 *         subClass=[JClass|EString]? 
	 *         context=Context?
	 *     )
	 */
	protected void sequence_HasSuperClassFilter(ISerializationContext context, HasSuperClassFilter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Filter returns ImplicitContentsFilter
	 *     ImplicitContentsFilter returns ImplicitContentsFilter
	 *
	 * Constraint:
	 *     (
	 *         negated?='not'? 
	 *         targets+=[Element|EString] 
	 *         targets+=[Element|EString]* 
	 *         implicitField=[Element|EString]? 
	 *         implicitContainer=[Element|EString]? 
	 *         context=Context?
	 *     )
	 */
	protected void sequence_ImplicitContentsFilter(ISerializationContext context, ImplicitContentsFilter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Filter returns ImplicityContainerFilter
	 *     ImplicityContainerFilter returns ImplicityContainerFilter
	 *
	 * Constraint:
	 *     (
	 *         negated?='not'? 
	 *         targets+=[Element|EString] 
	 *         targets+=[Element|EString]* 
	 *         implicityContainer=[Element|EString] 
	 *         implicityField=[Element|EString] 
	 *         context=Context
	 *     )
	 */
	protected void sequence_ImplicityContainerFilter(ISerializationContext context, ImplicityContainerFilter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Filter returns ImplicityOperandFilter
	 *     ImplicityOperandFilter returns ImplicityOperandFilter
	 *
	 * Constraint:
	 *     (
	 *         negated?='not'? 
	 *         targets+=[Element|EString] 
	 *         targets+=[Element|EString]* 
	 *         targetTemplate=[Element|EString] 
	 *         implicityOperand=[Element|EString] 
	 *         expression=[Expression|EString] 
	 *         context=Context
	 *     )
	 */
	protected void sequence_ImplicityOperandFilter(ISerializationContext context, ImplicityOperandFilter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ImportStatement returns ImportStatement
	 *
	 * Constraint:
	 *     (static?='static'? uniqueName=String0? importedElement=[ImportableElement|EString]?)
	 */
	protected void sequence_ImportStatement(ISerializationContext context, ImportStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Element returns ImportableElement
	 *     ImportableElement returns ImportableElement
	 *
	 * Constraint:
	 *     uniqueName=String0?
	 */
	protected void sequence_ImportableElement(ISerializationContext context, ImportableElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns InitializableVariable
	 *     InitializableVariable_Impl returns InitializableVariable
	 *
	 * Constraint:
	 *     (
	 *         uniqueName=String0? 
	 *         name=String0? 
	 *         availableInSourceCode=BooleanObject? 
	 *         final=BooleanObject? 
	 *         type=[DataType|EString]? 
	 *         (annotations+=Annotation annotations+=Annotation*)? 
	 *         initialValue=Expression?
	 *     )
	 */
	protected void sequence_InitializableVariable_Impl(ISerializationContext context, InitializableVariable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns InstanceCreation
	 *     Element returns InstanceCreation
	 *     InstanceCreation returns InstanceCreation
	 *
	 * Constraint:
	 *     (uniqueName=String0? argsKind=CollectionKind? type=[ObjectType|EString]? constructor=Constructor? (args+=Statement args+=Statement*)?)
	 */
	protected void sequence_InstanceCreation(ISerializationContext context, InstanceCreation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns InstanceofExpression
	 *     Element returns InstanceofExpression
	 *     InstanceofExpression returns InstanceofExpression
	 *
	 * Constraint:
	 *     (uniqueName=String0? type=[ObjectType|EString]? objectExpression=Expression?)
	 */
	protected void sequence_InstanceofExpression(ISerializationContext context, InstanceofExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataType returns IntPrimitiveType
	 *     Element returns IntPrimitiveType
	 *     IntPrimitiveType returns IntPrimitiveType
	 *
	 * Constraint:
	 *     uniqueName=String0?
	 */
	protected void sequence_IntPrimitiveType(ISerializationContext context, IntPrimitiveType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Filter returns IsEmptyBlockFilter
	 *     IsEmptyBlockFilter returns IsEmptyBlockFilter
	 *
	 * Constraint:
	 *     (negated?='not'? allowEmptyStatement=Boolean? allowComments=Boolean? targets+=[Element|EString] targets+=[Element|EString]*)
	 */
	protected void sequence_IsEmptyBlockFilter(ISerializationContext context, IsEmptyBlockFilter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Filter returns IsKindOfFilter
	 *     IsKindOfFilter returns IsKindOfFilter
	 *
	 * Constraint:
	 *     (negated?='not'? targets+=[Element|EString] targets+=[Element|EString]* type=[DataType|EString] context=Context)
	 */
	protected void sequence_IsKindOfFilter(ISerializationContext context, IsKindOfFilter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Filter returns IsStringFilter
	 *     IsStringFilter returns IsStringFilter
	 *
	 * Constraint:
	 *     (negated?='not'? targets+=[Element|EString] targets+=[Element|EString]*)
	 */
	protected void sequence_IsStringFilter(ISerializationContext context, IsStringFilter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Filter returns IsTypeOfFilter
	 *     IsTypeOfFilter returns IsTypeOfFilter
	 *
	 * Constraint:
	 *     (negated?='not'? targets+=[Element|EString] targets+=[Element|EString]* type=[DataType|EString] context=Context)
	 */
	protected void sequence_IsTypeOfFilter(ISerializationContext context, IsTypeOfFilter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeDeclaration returns JClass
	 *     ComplexType returns JClass
	 *     Element returns JClass
	 *     JClass returns JClass
	 *
	 * Constraint:
	 *     (
	 *         uniqueName=String0? 
	 *         name=String0? 
	 *         availableInSourceCode=BooleanObject? 
	 *         visibility=Visibility? 
	 *         static=BooleanObject? 
	 *         inheritance=Inheritance? 
	 *         fieldsKind=CollectionKind? 
	 *         methodsKind=CollectionKind? 
	 *         (superInterfaces+=[JInterface|EString] superInterfaces+=[JInterface|EString]*)? 
	 *         superClass=[JClass|EString]? 
	 *         (annotations+=Annotation annotations+=Annotation*)? 
	 *         (imports+=ImportStatement imports+=ImportStatement*)? 
	 *         (nestedTypes+=TypeDeclaration nestedTypes+=TypeDeclaration*)? 
	 *         (fields+=FieldVariable fields+=FieldVariable*)? 
	 *         (methods+=Method methods+=Method*)? 
	 *         (constructors+=Constructor constructors+=Constructor*)?
	 *     )
	 */
	protected void sequence_JClass(ISerializationContext context, JClass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeDeclaration returns JEnum
	 *     ComplexType returns JEnum
	 *     Element returns JEnum
	 *     JEnum returns JEnum
	 *
	 * Constraint:
	 *     (
	 *         uniqueName=String0? 
	 *         name=String0? 
	 *         availableInSourceCode=BooleanObject? 
	 *         visibility=Visibility? 
	 *         static=BooleanObject? 
	 *         inheritance=Inheritance? 
	 *         fieldsKind=CollectionKind? 
	 *         methodsKind=CollectionKind? 
	 *         (superInterfaces+=[JInterface|EString] superInterfaces+=[JInterface|EString]*)? 
	 *         (annotations+=Annotation annotations+=Annotation*)? 
	 *         (imports+=ImportStatement imports+=ImportStatement*)? 
	 *         (nestedTypes+=TypeDeclaration nestedTypes+=TypeDeclaration*)? 
	 *         (fields+=FieldVariable fields+=FieldVariable*)? 
	 *         (methods+=Method methods+=Method*)? 
	 *         (constructors+=Constructor constructors+=Constructor*)? 
	 *         (enumConstants+=EnumConstant enumConstants+=EnumConstant*)?
	 *     )
	 */
	protected void sequence_JEnum(ISerializationContext context, JEnum semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeDeclaration returns JInterface
	 *     ComplexType returns JInterface
	 *     Element returns JInterface
	 *     JInterface returns JInterface
	 *
	 * Constraint:
	 *     (
	 *         uniqueName=String0? 
	 *         name=String0? 
	 *         availableInSourceCode=BooleanObject? 
	 *         visibility=Visibility? 
	 *         static=BooleanObject? 
	 *         inheritance=Inheritance? 
	 *         fieldsKind=CollectionKind? 
	 *         methodsKind=CollectionKind? 
	 *         (superInterfaces+=[JInterface|EString] superInterfaces+=[JInterface|EString]*)? 
	 *         (annotations+=Annotation annotations+=Annotation*)? 
	 *         (imports+=ImportStatement imports+=ImportStatement*)? 
	 *         (nestedTypes+=TypeDeclaration nestedTypes+=TypeDeclaration*)? 
	 *         (fields+=FieldVariable fields+=FieldVariable*)? 
	 *         (methods+=Method methods+=Method*)?
	 *     )
	 */
	protected void sequence_JInterface(ISerializationContext context, JInterface semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns LabelStatement
	 *     Element returns LabelStatement
	 *     LabelStatement returns LabelStatement
	 *
	 * Constraint:
	 *     (uniqueName=String0? name=EString? body=Statement?)
	 */
	protected void sequence_LabelStatement(ISerializationContext context, LabelStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns LocalVariable
	 *     LocalVariable returns LocalVariable
	 *
	 * Constraint:
	 *     (
	 *         uniqueName=String0? 
	 *         name=String0? 
	 *         availableInSourceCode=BooleanObject? 
	 *         final=BooleanObject? 
	 *         type=[DataType|EString]? 
	 *         (annotations+=Annotation annotations+=Annotation*)? 
	 *         initialValue=Expression?
	 *     )
	 */
	protected void sequence_LocalVariable(ISerializationContext context, LocalVariable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataType returns LongPrimitiveType
	 *     Element returns LongPrimitiveType
	 *     LongPrimitiveType returns LongPrimitiveType
	 *
	 * Constraint:
	 *     uniqueName=String0?
	 */
	protected void sequence_LongPrimitiveType(ISerializationContext context, LongPrimitiveType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Method returns Method
	 *
	 * Constraint:
	 *     (
	 *         uniqueName=String0? 
	 *         (
	 *             (
	 *                 name=String0 | 
	 *                 availableInSourceCode=BooleanObject | 
	 *                 visibility=Visibility | 
	 *                 paramsKind=CollectionKind | 
	 *                 static=BooleanObject | 
	 *                 inheritance=Inheritance | 
	 *                 returnType=[DataType|EString] | 
	 *                 body=Block
	 *             )? 
	 *             (thrownExceptions+=[JClass|EString] thrownExceptions+=[JClass|EString]*)? 
	 *             (annotations+=Annotation annotations+=Annotation*)? 
	 *             (params+=ParameterVariable params+=ParameterVariable*)?
	 *         )+
	 *     )
	 */
	protected void sequence_Method(ISerializationContext context, Method semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NamedElement returns NamedElement
	 *     Element returns NamedElement
	 *     NamedElement_Impl returns NamedElement
	 *
	 * Constraint:
	 *     (uniqueName=String0? name=String0? availableInSourceCode=BooleanObject? (annotations+=Annotation annotations+=Annotation*)?)
	 */
	protected void sequence_NamedElement_Impl(ISerializationContext context, NamedElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataType returns ObjectType
	 *     ObjectType returns ObjectType
	 *     Element returns ObjectType
	 *     ObjectType_Impl returns ObjectType
	 *
	 * Constraint:
	 *     uniqueName=String0?
	 */
	protected void sequence_ObjectType_Impl(ISerializationContext context, ObjectType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns OperandExpression
	 *     Element returns OperandExpression
	 *     OperandExpression_Impl returns OperandExpression
	 *
	 * Constraint:
	 *     (uniqueName=String0? kind=ExpressionKind? operandsKind=CollectionKind? (operands+=Expression operands+=Expression*)?)
	 */
	protected void sequence_OperandExpression_Impl(ISerializationContext context, OperandExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NamedElement returns Package
	 *     Element returns Package
	 *     Package returns Package
	 *
	 * Constraint:
	 *     (
	 *         uniqueName=String0? 
	 *         name=String0? 
	 *         availableInSourceCode=BooleanObject? 
	 *         (annotations+=Annotation annotations+=Annotation*)? 
	 *         (declaredTypes+=TypeDeclaration declaredTypes+=TypeDeclaration*)?
	 *     )
	 */
	protected void sequence_Package(ISerializationContext context, ccsl.elements.namedElements.Package semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns ParameterVariable
	 *     ParameterVariable returns ParameterVariable
	 *
	 * Constraint:
	 *     (
	 *         uniqueName=String0? 
	 *         name=String0? 
	 *         availableInSourceCode=BooleanObject? 
	 *         final=BooleanObject? 
	 *         type=[DataType|EString]? 
	 *         (annotations+=Annotation annotations+=Annotation*)?
	 *     )
	 */
	protected void sequence_ParameterVariable(ISerializationContext context, ParameterVariable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataType returns ParameterizedType
	 *     ObjectType returns ParameterizedType
	 *     Element returns ParameterizedType
	 *     ParameterizedType returns ParameterizedType
	 *
	 * Constraint:
	 *     (uniqueName=String0? (typeArguments+=[ObjectType|EString] typeArguments+=[ObjectType|EString]*)? type=[TypeDeclaration|EString]?)
	 */
	protected void sequence_ParameterizedType(ISerializationContext context, ParameterizedType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataType returns PrimitiveType
	 *     Element returns PrimitiveType
	 *     PrimitiveType_Impl returns PrimitiveType
	 *
	 * Constraint:
	 *     uniqueName=String0?
	 */
	protected void sequence_PrimitiveType_Impl(ISerializationContext context, PrimitiveType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Filter returns PropertyFilter
	 *     PropertyFilter returns PropertyFilter
	 *
	 * Constraint:
	 *     (negated?='not'? targets+=[Element|EString] targets+=[Element|EString]*)
	 */
	protected void sequence_PropertyFilter(ISerializationContext context, PropertyFilter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Filter returns RegexMatch
	 *     RegexMatch returns RegexMatch
	 *
	 * Constraint:
	 *     (negated?='not'? regex=String0? targets+=[Element|EString] targets+=[Element|EString]*)
	 */
	protected void sequence_RegexMatch(ISerializationContext context, RegexMatch semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ReturnStatement
	 *     Element returns ReturnStatement
	 *     ReturnStatement returns ReturnStatement
	 *
	 * Constraint:
	 *     (uniqueName=String0? expression=Expression?)
	 */
	protected void sequence_ReturnStatement(ISerializationContext context, ReturnStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Filter returns SameNameFilter
	 *     SameNameFilter returns SameNameFilter
	 *
	 * Constraint:
	 *     (
	 *         negated?='not'? 
	 *         ignoreCase=Boolean? 
	 *         targets+=[Element|EString] 
	 *         targets+=[Element|EString]* 
	 *         (elements+=[NamedElement|EString] elements+=[NamedElement|EString]*)?
	 *     )
	 */
	protected void sequence_SameNameFilter(ISerializationContext context, SameNameFilter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataType returns ShortPrimitiveType
	 *     Element returns ShortPrimitiveType
	 *     ShortPrimitiveType returns ShortPrimitiveType
	 *
	 * Constraint:
	 *     uniqueName=String0?
	 */
	protected void sequence_ShortPrimitiveType(ISerializationContext context, ShortPrimitiveType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Element returns SimpleMethod
	 *     SimpleMethod returns SimpleMethod
	 *
	 * Constraint:
	 *     (
	 *         uniqueName=String0? 
	 *         ((visibility=Visibility | paramsKind=CollectionKind | body=Block)? (params+=ParameterVariable params+=ParameterVariable*)?)+
	 *     )
	 */
	protected void sequence_SimpleMethod(ISerializationContext context, SimpleMethod semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Statement
	 *     Element returns Statement
	 *     Statement_Impl returns Statement
	 *
	 * Constraint:
	 *     uniqueName=String0?
	 */
	protected void sequence_Statement_Impl(ISerializationContext context, Statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns StringConcatenation
	 *     Element returns StringConcatenation
	 *     StringConcatenation returns StringConcatenation
	 *
	 * Constraint:
	 *     (uniqueName=String0? kind=ExpressionKind? operandsKind=CollectionKind? (operands+=Expression operands+=Expression*)?)
	 */
	protected void sequence_StringConcatenation(ISerializationContext context, StringConcatenation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Filter returns SuperMethodClosureFilter
	 *     SuperMethodClosureFilter returns SuperMethodClosureFilter
	 *
	 * Constraint:
	 *     (negated?='not'? targets+=[Element|EString] targets+=[Element|EString]* superMethod=[Method|EString] context=Context)
	 */
	protected void sequence_SuperMethodClosureFilter(ISerializationContext context, SuperMethodClosureFilter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns SynchronizedBlock
	 *     Element returns SynchronizedBlock
	 *     SynchronizedBlock returns SynchronizedBlock
	 *
	 * Constraint:
	 *     (uniqueName=String0? (bodyStatements+=Statement bodyStatements+=Statement*)? key=Statement?)
	 */
	protected void sequence_SynchronizedBlock(ISerializationContext context, SynchronizedBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Filter returns TemplateFilter
	 *     TemplateFilter_Impl returns TemplateFilter
	 *
	 * Constraint:
	 *     (negated?='not'? targets+=[Element|EString] targets+=[Element|EString]* targetTemplate=[Element|EString] context=Context)
	 */
	protected void sequence_TemplateFilter_Impl(ISerializationContext context, TemplateFilter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns TernaryExpression
	 *     Element returns TernaryExpression
	 *     TernaryExpression returns TernaryExpression
	 *
	 * Constraint:
	 *     (uniqueName=String0? condition=Expression? elseExpression=Expression? thenExpression=Expression?)
	 */
	protected void sequence_TernaryExpression(ISerializationContext context, TernaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ThrowStatement
	 *     Element returns ThrowStatement
	 *     ThrowStatement returns ThrowStatement
	 *
	 * Constraint:
	 *     (uniqueName=String0? expression=Expression?)
	 */
	protected void sequence_ThrowStatement(ISerializationContext context, ThrowStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeDeclaration returns TypeDeclaration
	 *     NamedElement returns TypeDeclaration
	 *     Element returns TypeDeclaration
	 *     TypeDeclaration_Impl returns TypeDeclaration
	 *
	 * Constraint:
	 *     (
	 *         uniqueName=String0? 
	 *         name=String0? 
	 *         availableInSourceCode=BooleanObject? 
	 *         visibility=Visibility? 
	 *         static=BooleanObject? 
	 *         inheritance=Inheritance? 
	 *         (annotations+=Annotation annotations+=Annotation*)? 
	 *         (imports+=ImportStatement imports+=ImportStatement*)? 
	 *         (nestedTypes+=TypeDeclaration nestedTypes+=TypeDeclaration*)?
	 *     )
	 */
	protected void sequence_TypeDeclaration_Impl(ISerializationContext context, TypeDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataType returns TypeParameter
	 *     ObjectType returns TypeParameter
	 *     Element returns TypeParameter
	 *     TypeParameter returns TypeParameter
	 *
	 * Constraint:
	 *     (uniqueName=String0? boundsKind=CollectionKind? (bounds+=[ObjectType|EString] bounds+=[ObjectType|EString]*)?)
	 */
	protected void sequence_TypeParameter(ISerializationContext context, TypeParameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns VarDeclaration
	 *     Element returns VarDeclaration
	 *     VarDeclaration returns VarDeclaration
	 *
	 * Constraint:
	 *     (uniqueName=String0? variable=Variable?)
	 */
	protected void sequence_VarDeclaration(ISerializationContext context, VarDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns Variable
	 *     Variable_Impl returns Variable
	 *
	 * Constraint:
	 *     (
	 *         uniqueName=String0? 
	 *         name=String0? 
	 *         availableInSourceCode=BooleanObject? 
	 *         final=BooleanObject? 
	 *         type=[DataType|EString]? 
	 *         (annotations+=Annotation annotations+=Annotation*)?
	 *     )
	 */
	protected void sequence_Variable_Impl(ISerializationContext context, Variable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataType returns VoidType
	 *     Element returns VoidType
	 *     VoidType returns VoidType
	 *
	 * Constraint:
	 *     uniqueName=String0?
	 */
	protected void sequence_VoidType(ISerializationContext context, VoidType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataType returns WildCardType
	 *     ObjectType returns WildCardType
	 *     Element returns WildCardType
	 *     WildCardType returns WildCardType
	 *
	 * Constraint:
	 *     (uniqueName=String0? bound=[ObjectType|EString]?)
	 */
	protected void sequence_WildCardType(ISerializationContext context, WildCardType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
